name: SBOM Scan

on:
  push:
    branches: [ main ]
    tags:
      - 'v*'

jobs:
  scan:
    runs-on: ubuntu-latest
    # Restrict to specific branches for extra security
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v')
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for tags
      
      - name: Install Syft
        uses: anchore/sbom-action/download-syft@v0
      
      - name: Extract version
        id: version
        run: |
          if [ "${{ github.ref_type }}" == "tag" ]; then
            # If scanning a git tag, use the tag name (highest priority)
            VERSION="${{ github.ref_name }}"
            GIT_TAG="${{ github.ref_name }}"
            echo "‚úÖ Using version from git tag: $VERSION"
          elif [ -f "package.json" ]; then
            # Try to read version from package.json
            if command -v jq &> /dev/null; then
              VERSION=$(jq -r '.version' package.json 2>/dev/null || echo "")
            else
              # Fallback: use grep/sed if jq is not available
              VERSION=$(grep -o '"version"[[:space:]]*:[[:space:]]*"[^"]*"' package.json | sed 's/.*"version"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/' || echo "")
            fi
            
            # Validate version was found and is not null/empty
            if [ -z "$VERSION" ] || [ "$VERSION" == "null" ]; then
              echo "‚ö†Ô∏è Warning: No version found in package.json, using commit-based version"
              VERSION="main-$(git rev-parse --short HEAD)"
            else
              echo "‚úÖ Using version from package.json: $VERSION"
            fi
            GIT_TAG=""
          else
            # Fallback: use commit-based version
            VERSION="main-$(git rev-parse --short HEAD)"
            GIT_TAG=""
            echo "‚ÑπÔ∏è No package.json found, using commit-based version: $VERSION"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "git_tag=$GIT_TAG" >> $GITHUB_OUTPUT
          echo "git_commit_sha=${{ github.sha }}" >> $GITHUB_OUTPUT
      
      - name: Setup Node.js (if package.json exists)
        if: hashFiles('**/package.json') != ''
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install npm dependencies (if package.json exists)
        if: hashFiles('**/package.json') != ''
        run: |
          # Find all package.json files and install dependencies
          # We need package-lock.json for syft to detect packages
          find . -name "package.json" -not -path "*/node_modules/*" -print0 | while IFS= read -r -d '' pkg; do
            PKG_DIR=$(dirname "$pkg")
            (cd "$PKG_DIR" && npm install --no-audit --no-fund) || {
              echo "‚ö†Ô∏è Warning: npm install failed in $PKG_DIR"
            }
          done
      
      - name: Setup Python (if requirements.txt exists)
        if: hashFiles('**/requirements.txt') != ''
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Generate SBOM
        id: sbom
        run: |
          # Create .syftignore file to exclude non-package directories
          cat > .syftignore << EOF
          .github/
          .git/
          .next/
          out/
          __pycache__/
          *.pyc
          .venv/
          venv/
          .env*
          EOF
          
          # Scan the entire directory - syft will auto-detect npm packages from package-lock.json
          syft scan dir:. --scope all-layers -o cyclonedx-json > sbom.json 2>syft-warnings.log || {
            echo "‚ùå Syft scan failed"
            cat syft-warnings.log || true
            exit 1
          }
          
          # Validate JSON is valid
          if [ ! -s sbom.json ] || ! jq empty sbom.json 2>/dev/null; then
            echo "‚ùå Error: Generated SBOM is not valid JSON"
            if [ -s syft-warnings.log ]; then
              cat syft-warnings.log
            fi
            exit 1
          fi
      
      - name: Upload SBOM to Backend
        env:
          # Secrets are automatically masked in logs
          API_TOKEN: ${{ secrets.OSS_API_TOKEN }}
          API_URL: ${{ secrets.OSS_API_URL }}
        run: |
          # Validate API_URL is set and properly formatted
          if [ -z "$API_URL" ]; then
            echo "‚ùå Error: OSS_API_URL secret is not set"
            exit 1
          fi
          
          # Remove trailing slash if present
          API_URL=$(echo "$API_URL" | sed 's:/*$::')
          
          # Validate URL format (must start with http:// or https://)
          if [[ ! "$API_URL" =~ ^https?:// ]]; then
            echo "‚ùå Error: OSS_API_URL must start with http:// or https://"
            echo "Current value: $API_URL"
            exit 1
          fi
          
          # Validate API_TOKEN is set
          if [ -z "$API_TOKEN" ]; then
            echo "‚ùå Error: OSS_API_TOKEN secret is not set"
            exit 1
          fi
          
          echo "‚úÖ API URL: ${API_URL}"
          echo "‚úÖ API Token: ${API_TOKEN:0:10}... (masked)"
          echo "‚úÖ Repository: ${{ github.repository }}"
          echo "‚úÖ Version: ${{ steps.version.outputs.version }}"
          
          # Debug: Check SBOM file size
          echo "üìä SBOM file size: $(du -h sbom.json | cut -f1)"
          echo "üìä SBOM file line count: $(wc -l < sbom.json)"
          
          # Check if SBOM is too large and minify if needed
          SBOM_SIZE=$(stat -f%z sbom.json 2>/dev/null || stat -c%s sbom.json 2>/dev/null)
          echo "üìä SBOM exact size: $SBOM_SIZE bytes"
          
          # If SBOM is larger than 10MB, minify it
          if [ "$SBOM_SIZE" -gt 10485760 ]; then
            echo "‚ö†Ô∏è SBOM size exceeds 10MB, minifying..."
            jq -c . sbom.json > sbom.min.json
            mv sbom.min.json sbom.json
            SBOM_SIZE=$(stat -f%z sbom.json 2>/dev/null || stat -c%s sbom.json 2>/dev/null)
            echo "üìä Minified SBOM size: $SBOM_SIZE bytes"
          fi
          
          # Create payload with SBOM to avoid "Argument list too long" error
          cat > payload.json << 'PAYLOAD_EOF'
          {
            "repository_name": "${{ github.repository }}",
            "version": "${{ steps.version.outputs.version }}",
            "git_tag": "${{ steps.version.outputs.git_tag }}",
            "git_commit_sha": "${{ steps.version.outputs.git_commit_sha }}",
            "sbom_data": 
          PAYLOAD_EOF
          
          # Append SBOM data and close JSON
          cat sbom.json >> payload.json
          echo "}" >> payload.json
          
          PAYLOAD_SIZE=$(stat -f%z payload.json 2>/dev/null || stat -c%s payload.json 2>/dev/null)
          echo "üìä Total payload size: $PAYLOAD_SIZE bytes"
          
          # Retry logic with exponential backoff
          MAX_RETRIES=3
          RETRY_DELAY=5
          ATTEMPT=1
          
          while [ $ATTEMPT -le $MAX_RETRIES ]; do
            echo ""
            echo "üîÑ Upload attempt $ATTEMPT of $MAX_RETRIES..."
            
            # GitHub automatically masks the token if it appears in output
            # Using verbose mode (-v) to debug connection issues
            HTTP_CODE=$(curl -s -o response.json -w "%{http_code}" \
              -X POST "${API_URL}/scans/trigger" \
              -H "Authorization: Bearer ${API_TOKEN}" \
              -H "Content-Type: application/json" \
              --max-time 120 \
              --connect-timeout 30 \
              -v \
              -d @payload.json 2>&1 | tee curl-debug.log | grep "^< HTTP" | awk '{print $3}')
            
            echo "üìä HTTP Status: $HTTP_CODE"
            
            # Show response if available
            if [ -s response.json ]; then
              echo "üìù Response: $(head -c 500 response.json)"
            fi
            
            # Check if successful
            if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "201" ] || [ "$HTTP_CODE" = "202" ]; then
              echo "‚úÖ SBOM uploaded successfully!"
              echo "üìù Full response:"
              cat response.json || true
              exit 0
            fi
            
            # If 504 or 502 or 503, retry
            if [ "$HTTP_CODE" = "504" ] || [ "$HTTP_CODE" = "502" ] || [ "$HTTP_CODE" = "503" ]; then
              if [ $ATTEMPT -lt $MAX_RETRIES ]; then
                echo "‚ö†Ô∏è Server error ($HTTP_CODE), retrying in ${RETRY_DELAY}s..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
                ATTEMPT=$((ATTEMPT + 1))
                continue
              fi
            else
              # For other errors, don't retry
              echo "‚ùå Upload failed with HTTP $HTTP_CODE"
              echo "üìù Full response:"
              cat response.json || true
              echo ""
              echo "üîç Debug log:"
              tail -20 curl-debug.log || true
              exit 1
            fi
          done
          
          echo "‚ùå Failed to upload SBOM after $MAX_RETRIES attempts"
          exit 1
