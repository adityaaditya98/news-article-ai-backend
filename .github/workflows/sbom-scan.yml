name: SBOM Scan

on:
  push:
    branches: [ main ]
    tags:
      - 'v*'

jobs:
  scan:
    runs-on: ubuntu-latest
    # Restrict to specific branches for extra security
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v')
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for tags
      
      - name: Install Syft
        uses: anchore/sbom-action/download-syft@v0

      - name: Ensure jq is installed
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          else
            echo "jq already installed"
          fi
      
      - name: Extract version
        id: version
        run: |
          if [ "${{ github.ref_type }}" == "tag" ]; then
            # If scanning a git tag, use the tag name (highest priority)
            VERSION="${{ github.ref_name }}"
            GIT_TAG="${{ github.ref_name }}"
            echo "âœ… Using version from git tag: $VERSION"
          elif [ -f "package.json" ]; then
            # Try to read version from package.json
            if command -v jq &> /dev/null; then
              VERSION=$(jq -r '.version' package.json 2>/dev/null || echo "")
            else
              # Fallback: use grep/sed if jq is not available
              VERSION=$(grep -o '"version"[[:space:]]*:[[:space:]]*"[^"]*"' package.json | sed 's/.*"version"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/' || echo "")
            fi
            
            # Validate version was found and is not null/empty
            if [ -z "$VERSION" ] || [ "$VERSION" == "null" ]; then
              echo "âš ï¸ Warning: No version found in package.json, using commit-based version"
              VERSION="main-$(git rev-parse --short HEAD)"
            else
              echo "âœ… Using version from package.json: $VERSION"
            fi
            GIT_TAG=""
          else
            # Fallback: use commit-based version
            VERSION="main-$(git rev-parse --short HEAD)"
            GIT_TAG=""
            echo "â„¹ï¸ No package.json found, using commit-based version: $VERSION"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "git_tag=$GIT_TAG" >> $GITHUB_OUTPUT
          echo "git_commit_sha=${{ github.sha }}" >> $GITHUB_OUTPUT
      
      - name: Setup Node.js (if package.json exists)
        if: hashFiles('**/package.json') != ''
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install npm dependencies (if package.json exists)
        if: hashFiles('**/package.json') != ''
        run: |
          # Find all package.json files and install dependencies
          # We need package-lock.json for syft to detect packages
          find . -name "package.json" -not -path "*/node_modules/*" -print0 | while IFS= read -r -d '' pkg; do
            PKG_DIR=$(dirname "$pkg")
            (cd "$PKG_DIR" && npm install --no-audit --no-fund) || {
              echo "âš ï¸ Warning: npm install failed in $PKG_DIR"
            }
          done
      
      - name: Setup Python (if requirements.txt exists)
        if: hashFiles('**/requirements.txt') != ''
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Generate SBOM
        id: sbom
        run: |
          # Create .syftignore file to exclude non-package directories
          printf '%s\n' \
            ".github/" \
            ".git/" \
            ".next/" \
            "out/" \
            "__pycache__/" \
            "*.pyc" \
            ".venv/" \
            "venv/" \
            ".env*" > .syftignore
          
          # Scan the entire directory - syft will auto-detect npm packages from package-lock.json
          syft scan dir:. --scope all-layers -o cyclonedx-json > sbom.json 2>syft-warnings.log || {
            echo "âŒ Syft scan failed"
            cat syft-warnings.log || true
            exit 1
          }
          
          # Validate JSON is valid
          if [ ! -s sbom.json ] || ! jq empty sbom.json 2>/dev/null; then
            echo "âŒ Error: Generated SBOM is not valid JSON"
            if [ -s syft-warnings.log ]; then
              cat syft-warnings.log
            fi
            exit 1
          fi
      
      - name: Upload SBOM to Backend
        env:
          # Secrets are automatically masked in logs
          API_TOKEN: ${{ secrets.OSS_API_TOKEN }}
          API_URL: ${{ secrets.OSS_API_URL }}
        run: |
          # Validate API_URL is set and properly formatted
          if [ -z "$API_URL" ]; then
            echo "âŒ Error: OSS_API_URL secret is not set"
            exit 1
          fi
          
          # Remove trailing slash if present
          API_URL=$(echo "$API_URL" | sed 's:/*$::')
          
          # Validate URL format (must start with http:// or https://)
          if [[ ! "$API_URL" =~ ^https?:// ]]; then
            echo "âŒ Error: OSS_API_URL must start with http:// or https://"
            echo "Current value: $API_URL"
            exit 1
          fi
          
          # Validate API_TOKEN is set
          if [ -z "$API_TOKEN" ]; then
            echo "âŒ Error: OSS_API_TOKEN secret is not set"
            exit 1
          fi
          
          echo "âœ… API URL: ${API_URL}"
          echo "âœ… API Token: set (hidden)"
          echo "âœ… Repository: ${{ github.repository }}"
          echo "âœ… Version: ${{ steps.version.outputs.version }}"
          
          # Test endpoint connectivity first
          echo ""
          echo "ðŸ” Testing endpoint connectivity..."
          curl -s -o /dev/null -w "Connection test - HTTP Status: %{http_code}\n" \
            --connect-timeout 10 \
            --max-time 15 \
            "${API_URL}/health" || echo "âš ï¸ Health check endpoint unavailable (expected if not implemented)"
          
          # Debug: Check SBOM file structure
          echo ""
          echo "ðŸ“Š SBOM file size: $(du -h sbom.json 2>/dev/null | cut -f1 || echo 'N/A')"
          echo "ðŸ“Š SBOM file line count: $(wc -l < sbom.json)"
          
          # Check if SBOM is too large and minify
          SBOM_SIZE=$(stat -f%z sbom.json 2>/dev/null || stat -c%s sbom.json 2>/dev/null)
          echo "ðŸ“Š SBOM exact size: $SBOM_SIZE bytes"
          
          # Minify SBOM to reduce payload
          echo "ðŸ”§ Minifying SBOM..."
          jq -c . sbom.json > sbom.min.json
          mv sbom.min.json sbom.json
          SBOM_SIZE=$(stat -f%z sbom.json 2>/dev/null || stat -c%s sbom.json 2>/dev/null)
          echo "ðŸ“Š Minified SBOM size: $SBOM_SIZE bytes"
          
          # Extract only essential SBOM metadata to reduce size further if needed
          echo "ðŸ”§ Creating reduced SBOM with essential components..."
          jq -c '{
            "bomFormat": .bomFormat,
            "specVersion": .specVersion,
            "version": .version,
            "metadata": ({
              "timestamp": (.metadata.timestamp // null),
              "tools": (.metadata.tools[0:1] // [])
            } // {}),
            "components": (.components // [] | if type == "array" then sort_by(.name // "") | .[0:50] else [] end)
          }' sbom.json > sbom-reduced.json 2>&1 || {
            echo "âš ï¸ Failed to create reduced SBOM, using minified full SBOM instead"
            cp sbom.json sbom-reduced.json
          }
          
          REDUCED_SIZE=$(stat -f%z sbom-reduced.json 2>/dev/null || stat -c%s sbom-reduced.json 2>/dev/null)
          echo "ðŸ“Š Reduced SBOM size (first 50 components): $REDUCED_SIZE bytes"
          
          # Create full payload (prefer `jq` for safe JSON composition)
          echo ""
          echo "ðŸ”§ Creating full payload..."
          if command -v jq &> /dev/null; then
            jq -n \
              --arg repository "${{ github.repository }}" \
              --arg version "${{ steps.version.outputs.version }}" \
              --arg git_tag "${{ steps.version.outputs.git_tag }}" \
              --arg git_commit_sha "${{ steps.version.outputs.git_commit_sha }}" \
              --slurpfile sbom sbom.json \
              '{repository_name:$repository,version:$version,git_tag:$git_tag,git_commit_sha:$git_commit_sha,sbom_data:$sbom[0]}' \
              > payload.json || {
              echo "âš ï¸ Failed to create payload.json with jq"
              exit 1
            }
          else
            echo "â„¹ï¸ jq not available - falling back to manual payload assembly"
            printf '%s\n' '{' \
              "  \"repository_name\": \"${{ github.repository }}\"," \
              "  \"version\": \"${{ steps.version.outputs.version }}\"," \
              "  \"git_tag\": \"${{ steps.version.outputs.git_tag }}\"," \
              "  \"git_commit_sha\": \"${{ steps.version.outputs.git_commit_sha }}\"," \
              "  \"sbom_data\": " > payload.json

            cat sbom.json >> payload.json
            echo "}" >> payload.json
          fi

          PAYLOAD_SIZE=$(stat -f%z payload.json 2>/dev/null || stat -c%s payload.json 2>/dev/null || echo "0")
          echo "ðŸ“Š Total payload size: $PAYLOAD_SIZE bytes"

          # Validate payload JSON if possible
          if command -v jq &> /dev/null; then
            if ! jq empty payload.json 2>/dev/null; then
              echo "âŒ payload.json is not valid JSON"
              echo "ðŸ“„ payload.json preview (first 200 chars):"
              head -c 200 payload.json || true
              exit 1
            fi
          else
            echo "â„¹ï¸ jq not found; skipping payload JSON validation"
          fi

          # Debug: Show payload structure (first 200 chars)
          echo "ðŸ” Payload structure (first 200 chars):"
          head -c 200 payload.json | sed 's/[[:space:]]//g' | head -c 200 || true
          echo "..."
          
          # Retry logic with exponential backoff
          MAX_RETRIES=5
          RETRY_DELAY=10
          ATTEMPT=1
          UPLOAD_SUCCESS=0
          
          while [ $ATTEMPT -le $MAX_RETRIES ] && [ $UPLOAD_SUCCESS -eq 0 ]; do
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ðŸ”„ Upload attempt $ATTEMPT of $MAX_RETRIES"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            
            # Perform upload with reliable HTTP code capture and curl error handling
            HTTP_CODE_FILE=$(mktemp)
            curl -sS --max-time 180 --connect-timeout 30 -X POST "${API_URL}/scans/trigger" \
              -H "Authorization: Bearer ${API_TOKEN}" \
              -H "Content-Type: application/json" \
              -d @payload.json -o response.json -w "%{http_code}" >"$HTTP_CODE_FILE" 2>curl.err
            CURL_EXIT=$?
            HTTP_CODE=$(cat "$HTTP_CODE_FILE" 2>/dev/null || echo "")
            rm -f "$HTTP_CODE_FILE"

            if [ $CURL_EXIT -ne 0 ]; then
              echo "âš ï¸ curl failed with exit code $CURL_EXIT"
            fi

            echo "ðŸ“Š HTTP Status Code: ${HTTP_CODE:-(none)}"
            echo "ðŸ“Š Response size: $(stat -f%z response.json 2>/dev/null || stat -c%s response.json 2>/dev/null || echo '0') bytes"
            
            # Show response content
            if [ -s response.json ]; then
              RESPONSE_LENGTH=$(wc -c < response.json)
              if [ $RESPONSE_LENGTH -lt 1000 ]; then
                echo "ðŸ“ Response body:"
                cat response.json
              else
                echo "ðŸ“ Response (first 1000 chars):"
                head -c 1000 response.json
                echo "..."
              fi
            fi
            
            # Check if successful
            if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "201" ] || [ "$HTTP_CODE" = "202" ]; then
              echo ""
              echo "âœ… SBOM uploaded successfully on attempt $ATTEMPT!"
              UPLOAD_SUCCESS=1
              continue
            fi
            
            # Handle server errors with retry
            if [ "$HTTP_CODE" = "504" ] || [ "$HTTP_CODE" = "502" ] || [ "$HTTP_CODE" = "503" ] || [ "$HTTP_CODE" = "408" ]; then
              if [ $ATTEMPT -lt $MAX_RETRIES ]; then
                echo "âš ï¸ Server error ($HTTP_CODE), waiting ${RETRY_DELAY}s before retry..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
                ATTEMPT=$((ATTEMPT + 1))
                continue
              fi
            fi
            
            # Handle client errors or final attempt failure
            echo "âŒ Upload failed with HTTP $HTTP_CODE on attempt $ATTEMPT"
            
            if [ $ATTEMPT -eq $MAX_RETRIES ]; then
              echo ""
              echo "âŒ Failed to upload SBOM after $MAX_RETRIES attempts"
              echo "âš ï¸ Possible causes:"
              echo "  - Backend service is unavailable or unreachable"
              echo "  - Incorrect API endpoint: ${API_URL}/scans/trigger"
              echo "  - Invalid authentication token"
              echo "  - Network connectivity issues"
              echo "  - Request payload format incompatibility"
              exit 1
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
          done
          
          if [ $UPLOAD_SUCCESS -eq 1 ]; then
            echo "âœ… SBOM successfully uploaded to backend!"
          fi
