name: SBOM Scan

on:
  push:
    branches: [ main ]
    tags:
      - 'v*'

jobs:
  scan:
    runs-on: ubuntu-latest
    # Restrict to specific branches for extra security
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v')
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for tags
      
      - name: Install Syft
        uses: anchore/sbom-action/download-syft@v0
      
      - name: Extract version
        id: version
        run: |
          if [ "${{ github.ref_type }}" == "tag" ]; then
            # If scanning a git tag, use the tag name (highest priority)
            VERSION="${{ github.ref_name }}"
            GIT_TAG="${{ github.ref_name }}"
            echo "âœ… Using version from git tag: $VERSION"
          elif [ -f "package.json" ]; then
            # Try to read version from package.json
            if command -v jq &> /dev/null; then
              VERSION=$(jq -r '.version' package.json 2>/dev/null || echo "")
            else
              # Fallback: use grep/sed if jq is not available
              VERSION=$(grep -o '"version"[[:space:]]*:[[:space:]]*"[^"]*"' package.json | sed 's/.*"version"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/' || echo "")
            fi
            
            # Validate version was found and is not null/empty
            if [ -z "$VERSION" ] || [ "$VERSION" == "null" ]; then
              echo "âš ï¸ Warning: No version found in package.json, using commit-based version"
              VERSION="main-$(git rev-parse --short HEAD)"
            else
              echo "âœ… Using version from package.json: $VERSION"
            fi
            GIT_TAG=""
          else
            # Fallback: use commit-based version
            VERSION="main-$(git rev-parse --short HEAD)"
            GIT_TAG=""
            echo "â„¹ï¸ No package.json found, using commit-based version: $VERSION"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "git_tag=$GIT_TAG" >> $GITHUB_OUTPUT
          echo "git_commit_sha=${{ github.sha }}" >> $GITHUB_OUTPUT
      
      - name: Setup Node.js (if package.json exists)
        if: hashFiles('**/package.json') != ''
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install npm dependencies (if package.json exists)
        if: hashFiles('**/package.json') != ''
        run: |
          # Find all package.json files and install dependencies
          # We need package-lock.json for syft to detect packages
          find . -name "package.json" -not -path "*/node_modules/*" -print0 | while IFS= read -r -d '' pkg; do
            PKG_DIR=$(dirname "$pkg")
            (cd "$PKG_DIR" && npm install --no-audit --no-fund) || {
              echo "âš ï¸ Warning: npm install failed in $PKG_DIR"
            }
          done
      
      - name: Setup Python (if requirements.txt exists)
        if: hashFiles('**/requirements.txt') != ''
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Generate SBOM
        id: sbom
        run: |
          # Create .syftignore file to exclude non-package directories
          cat > .syftignore << EOF
          .github/
          .git/
          .next/
          out/
          __pycache__/
          *.pyc
          .venv/
          venv/
          .env*
          EOF
          
          # Scan the entire directory - syft will auto-detect npm packages from package-lock.json
          syft scan dir:. --scope all-layers -o cyclonedx-json > sbom.json 2>syft-warnings.log || {
            echo "âŒ Syft scan failed"
            cat syft-warnings.log || true
            exit 1
          }
          
          # Validate JSON is valid
          if [ ! -s sbom.json ] || ! jq empty sbom.json 2>/dev/null; then
            echo "âŒ Error: Generated SBOM is not valid JSON"
            if [ -s syft-warnings.log ]; then
              cat syft-warnings.log
            fi
            exit 1
          fi
      
      - name: Upload SBOM to Backend
        env:
          # Secrets are automatically masked in logs
          API_TOKEN: ${{ secrets.OSS_API_TOKEN }}
          API_URL: ${{ secrets.OSS_API_URL }}
        run: |
          # Validate API_URL is set and properly formatted
          if [ -z "$API_URL" ]; then
            echo "âŒ Error: OSS_API_URL secret is not set"
            exit 1
          fi
          
          # Remove trailing slash if present
          API_URL=$(echo "$API_URL" | sed 's:/*$::')
          
          # Validate URL format (must start with http:// or https://)
          if [[ ! "$API_URL" =~ ^https?:// ]]; then
            echo "âŒ Error: OSS_API_URL must start with http:// or https://"
            echo "Current value: $API_URL"
            exit 1
          fi
          
          # Validate API_TOKEN is set
          if [ -z "$API_TOKEN" ]; then
            echo "âŒ Error: OSS_API_TOKEN secret is not set"
            exit 1
          fi
          
          echo "âœ… API URL: ${API_URL}"
          echo "âœ… API Token: ${API_TOKEN:0:10}... (masked)"
          echo "âœ… Repository: ${{ github.repository }}"
          echo "âœ… Version: ${{ steps.version.outputs.version }}"
          
          # Test endpoint connectivity first
          echo ""
          echo "ðŸ” Testing endpoint connectivity..."
          curl -s -o /dev/null -w "Connection test - HTTP Status: %{http_code}\n" \
            --connect-timeout 10 \
            --max-time 15 \
            "${API_URL}/health" || echo "âš ï¸ Health check endpoint unavailable (expected if not implemented)"
          
          # Debug: Check SBOM file structure
          echo ""
          echo "ðŸ“Š SBOM file size: $(du -h sbom.json 2>/dev/null | cut -f1 || echo 'N/A')"
          echo "ðŸ“Š SBOM file line count: $(wc -l < sbom.json)"
          
          # Check if SBOM is too large and minify
          SBOM_SIZE=$(stat -f%z sbom.json 2>/dev/null || stat -c%s sbom.json 2>/dev/null)
          echo "ðŸ“Š SBOM exact size: $SBOM_SIZE bytes"
          
          # Minify SBOM to reduce payload
          echo "ðŸ”§ Minifying SBOM..."
          jq -c . sbom.json > sbom.min.json
          mv sbom.min.json sbom.json
          SBOM_SIZE=$(stat -f%z sbom.json 2>/dev/null || stat -c%s sbom.json 2>/dev/null)
          echo "ðŸ“Š Minified SBOM size: $SBOM_SIZE bytes"
          
          # Extract only essential SBOM metadata to reduce size further if needed
          echo "ðŸ”§ Creating reduced SBOM with essential components..."
          jq '{
            "bomFormat": .bomFormat,
            "specVersion": .specVersion,
            "version": .version,
            "metadata": {
              "timestamp": .metadata.timestamp,
              "tools": .metadata.tools[0:1]
            },
            "components": (.components | sort_by(.name)[:50])
          }' sbom.json > sbom-reduced.json
          
          REDUCED_SIZE=$(stat -f%z sbom-reduced.json 2>/dev/null || stat -c%s sbom-reduced.json 2>/dev/null)
          echo "ðŸ“Š Reduced SBOM size (first 50 components): $REDUCED_SIZE bytes"
          
          # Create full payload
          echo ""
          echo "ðŸ”§ Creating full payload..."
          cat > payload.json << 'PAYLOAD_EOF'
          {
            "repository_name": "${{ github.repository }}",
            "version": "${{ steps.version.outputs.version }}",
            "git_tag": "${{ steps.version.outputs.git_tag }}",
            "git_commit_sha": "${{ steps.version.outputs.git_commit_sha }}",
            "sbom_data": 
          PAYLOAD_EOF
          
          cat sbom.json >> payload.json
          echo "}" >> payload.json
          
          PAYLOAD_SIZE=$(stat -f%z payload.json 2>/dev/null || stat -c%s payload.json 2>/dev/null)
          echo "ðŸ“Š Total payload size: $PAYLOAD_SIZE bytes"
          
          # Debug: Show payload structure
          echo "ðŸ” Payload structure (first 200 chars):"
          head -c 200 payload.json | sed 's/[[:space:]]//g' | head -c 200
          echo "..."
          
          # Retry logic with exponential backoff
          MAX_RETRIES=5
          RETRY_DELAY=10
          ATTEMPT=1
          UPLOAD_SUCCESS=0
          
          while [ $ATTEMPT -le $MAX_RETRIES ] && [ $UPLOAD_SUCCESS -eq 0 ]; do
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ðŸ”„ Upload attempt $ATTEMPT of $MAX_RETRIES"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            
            # Perform upload with detailed debugging
            HTTP_CODE=$(curl -s -w "%{http_code}" \
              -X POST "${API_URL}/scans/trigger" \
              -H "Authorization: Bearer ${API_TOKEN}" \
              -H "Content-Type: application/json" \
              --max-time 180 \
              --connect-timeout 30 \
              --no-buffer \
              -d @payload.json \
              -o response.json 2>&1 | tail -1)
            
            echo "ðŸ“Š HTTP Status Code: $HTTP_CODE"
            echo "ðŸ“Š Response size: $(stat -f%z response.json 2>/dev/null || stat -c%s response.json 2>/dev/null) bytes"
            
            # Show response content
            if [ -s response.json ]; then
              RESPONSE_LENGTH=$(wc -c < response.json)
              if [ $RESPONSE_LENGTH -lt 1000 ]; then
                echo "ðŸ“ Response body:"
                cat response.json
              else
                echo "ðŸ“ Response (first 1000 chars):"
                head -c 1000 response.json
                echo "..."
              fi
            fi
            
            # Check if successful
            if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "201" ] || [ "$HTTP_CODE" = "202" ]; then
              echo ""
              echo "âœ… SBOM uploaded successfully on attempt $ATTEMPT!"
              UPLOAD_SUCCESS=1
              continue
            fi
            
            # Handle server errors with retry
            if [ "$HTTP_CODE" = "504" ] || [ "$HTTP_CODE" = "502" ] || [ "$HTTP_CODE" = "503" ] || [ "$HTTP_CODE" = "408" ]; then
              if [ $ATTEMPT -lt $MAX_RETRIES ]; then
                echo "âš ï¸ Server error ($HTTP_CODE), waiting ${RETRY_DELAY}s before retry..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
                ATTEMPT=$((ATTEMPT + 1))
                continue
              fi
            fi
            
            # Handle client errors or final attempt failure
            echo "âŒ Upload failed with HTTP $HTTP_CODE on attempt $ATTEMPT"
            
            if [ $ATTEMPT -eq $MAX_RETRIES ]; then
              echo ""
              echo "âŒ Failed to upload SBOM after $MAX_RETRIES attempts"
              echo "âš ï¸ Possible causes:"
              echo "  - Backend service is unavailable or unreachable"
              echo "  - Incorrect API endpoint: ${API_URL}/scans/trigger"
              echo "  - Invalid authentication token"
              echo "  - Network connectivity issues"
              echo "  - Request payload format incompatibility"
              exit 1
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
          done
          
          if [ $UPLOAD_SUCCESS -eq 1 ]; then
            echo "âœ… SBOM successfully uploaded to backend!"
          fi
